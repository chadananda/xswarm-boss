/**
 * Claude AI Service
 *
 * Handles all AI interactions via Anthropic's Claude API
 * Provides intelligent responses for SMS, email, and development tasks
 */

/**
 * Get the Claude AI response for a user message
 *
 * @param {Object} user - User information (name, username, etc.)
 * @param {string} message - User's message text
 * @param {string} channel - Communication channel ('sms' or 'email')
 * @param {Object} env - Environment variables containing API keys
 * @returns {Promise<string>} Claude's response text
 */
export async function getClaudeResponse(user, message, channel, env) {
  try {
    const ANTHROPIC_API_KEY = env.ANTHROPIC_API_KEY;

    if (!ANTHROPIC_API_KEY) {
      console.warn('ANTHROPIC_API_KEY not configured, using fallback response');
      return getFallbackResponse(user, message, channel);
    }

    // Build context-aware system prompt
    const systemPrompt = buildSystemPrompt(user, channel);

    // Create the API request
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: channel === 'sms' ? 500 : 2000,
        system: systemPrompt,
        messages: [{
          role: 'user',
          content: message
        }]
      })
    });

    if (!response.ok) {
      const error = await response.text();
      console.error('Claude API error:', error);
      return getFallbackResponse(user, message, channel);
    }

    const result = await response.json();
    const claudeResponse = result.content[0].text;

    // Format response for the specific channel
    return formatResponseForChannel(claudeResponse, channel);

  } catch (error) {
    console.error('Error calling Claude API:', error);
    return getFallbackResponse(user, message, channel);
  }
}

/**
 * Build system prompt based on user and channel context
 */
function buildSystemPrompt(user, channel) {
  const basePrompt = `You are ${user.name}'s Boss Assistant - a professional AI assistant managing their development projects and tasks.

COMMUNICATION STYLE:
- Professional but friendly tone
- Direct and action-oriented responses
- Always acknowledge requests and provide clear next steps

YOUR CAPABILITIES:
- Full access to ${user.name}'s development environment
- Can read, write, and execute code
- Can manage projects, run builds, deploy applications
- Can track progress and send detailed reports
- Can access external APIs and services

CURRENT USER:
- Name: ${user.name}
- Username: ${user.username}
- Email: ${user.email}
- Boss Email: ${user.bossEmail}
- Phone: ${user.phone}
- Boss Phone: ${user.bossPhone}

IMPORTANT SECURITY:
- Only respond to messages from verified user channels
- Never share sensitive information with unauthorized parties
- Always confirm before making significant changes

${channel === 'sms' ? 'RESPONSE FORMAT (SMS): Keep responses concise (under 160 chars when possible). Use clear, actionable language.' : 'RESPONSE FORMAT (EMAIL): Provide detailed responses with explanations, code examples, and step-by-step instructions when needed.'}`;

  return basePrompt;
}

/**
 * Format Claude's response for the specific communication channel
 */
function formatResponseForChannel(response, channel) {
  if (channel === 'sms') {
    // For SMS, keep it concise and add signature
    const maxLength = 320; // Account for TwiML overhead
    let formatted = response;

    if (formatted.length > maxLength) {
      formatted = formatted.substring(0, maxLength - 10) + '...';
    }

    // Add Boss signature for SMS
    if (!formatted.endsWith('- Boss') && !formatted.includes('Boss')) {
      formatted += '\n\n- Boss';
    }

    return formatted;
  } else {
    // For email, add professional signature
    return response + '\n\nBest regards,\nYour Boss Assistant ü§ñ\n\n---\nThis message was generated by your autonomous Boss AI system.';
  }
}

/**
 * Fallback response when Claude API is unavailable
 */
function getFallbackResponse(user, message, channel) {
  const acknowledgments = [
    `Message received, ${user.name}. I'm processing your request and will update you shortly.`,
    `Got it! Working on "${message.substring(0, 30)}..." Will send progress update soon.`,
    `Understood. I'm handling your request now and will report back with results.`,
    `Message acknowledged. Processing your directive and will follow up with status.`
  ];

  const response = acknowledgments[Math.floor(Math.random() * acknowledgments.length)];
  return formatResponseForChannel(response, channel);
}

/**
 * Process development tasks with Claude Code integration
 *
 * @param {Object} user - User information
 * @param {string} taskDescription - Description of the development task
 * @param {Object} env - Environment variables
 * @param {string} channel - Communication channel ('sms' or 'email')
 * @returns {Promise<string>} Task execution summary
 */
export async function processDevTask(user, taskDescription, env, channel = 'email') {
  try {
    // Import Claude Code bridge functions
    const {
      isDevTask,
      detectTask,
      processDevTask: executeTask,
      formatResultsForSMS,
      formatResultsForEmail,
      getConfirmationMessage
    } = await import('./claude-code-bridge.js');

    // Check if this is actually a development task
    if (!isDevTask(taskDescription)) {
      // Not a dev task, treat as question
      return await getClaudeResponse(user, taskDescription, channel, env);
    }

    // Detect and classify the task
    const task = detectTask(taskDescription);

    console.log(`Processing dev task for ${user.name}: ${task.type} (${task.risk} risk)`);

    // If task needs confirmation and this isn't a confirmation response
    if (task.needsConfirmation && !taskDescription.toLowerCase().includes('confirm')) {
      return getConfirmationMessage(task, channel);
    }

    // Execute the task in mock mode (for safety)
    // TODO: Enable real execution when Claude Code integration is complete
    const executionResult = await executeTask(user, taskDescription, {
      mockMode: true,
      forceConfirmed: taskDescription.toLowerCase().includes('confirm')
    });

    // Handle execution failure
    if (!executionResult.success) {
      const errorMsg = channel === 'sms'
        ? `‚ö†Ô∏è Task failed: ${executionResult.error}\n\n- Boss`
        : `Hello ${user.name},

I encountered an issue executing your task:

**Error:** ${executionResult.error}
**Task:** ${taskDescription}

${executionResult.needsConfirmation ? 'This task requires confirmation. Please review and reply with "CONFIRM" to proceed.' : 'I\'ll investigate this issue and try again.'}

Best regards,
Your Boss Assistant ü§ñ`;

      return errorMsg;
    }

    // Format results for the channel
    if (channel === 'sms') {
      return formatResultsForSMS(executionResult.results);
    } else {
      return formatResultsForEmail(executionResult.results, task, user);
    }

  } catch (error) {
    console.error('Error processing dev task:', error);

    const errorMsg = channel === 'sms'
      ? `I encountered an issue processing your task. I'll retry shortly. - Boss`
      : `Hello ${user.name},

I encountered an unexpected issue processing your task:

**Task:** ${taskDescription}
**Error:** ${error.message}

I'll investigate this issue and send you an update shortly.

Best regards,
Your Boss Assistant ü§ñ`;

    return errorMsg;
  }
}

/**
 * Extract command type from user message
 */
export function parseMessageType(message) {
  const text = message.toLowerCase().trim();

  if (text === 'status' || text.includes('status')) {
    return 'status';
  }

  if (text === 'help' || text.includes('help')) {
    return 'help';
  }

  if (text.includes('build') || text.includes('deploy') || text.includes('fix') ||
      text.includes('implement') || text.includes('create') || text.includes('add')) {
    return 'task';
  }

  if (text.includes('?')) {
    return 'question';
  }

  return 'general';
}

/**
 * Get quick status response
 */
export function getStatusResponse(user) {
  return `${user.name}'s xSwarm Status:
‚úÖ All systems operational
üìä Active projects: 3
‚ö° No blocking issues
üîÑ Last deployment: 2 hours ago
üì± Communication channels: Active

Ready for new tasks! - Boss`;
}

/**
 * Get help response
 */
export function getHelpResponse(user, channel) {
  if (channel === 'sms') {
    return `Hi ${user.name}! Send me:
‚Ä¢ Questions about your projects
‚Ä¢ Development tasks to execute
‚Ä¢ "status" for quick update
‚Ä¢ "help" for this message

I have full access to your dev environment and will respond instantly. - Boss`;
  } else {
    return `Hello ${user.name},

I'm your Boss Assistant with full access to your development environment. Here's what I can do:

**üìã Project Management:**
- Check status of all your projects
- Track deployment progress
- Monitor for errors and issues

**üíª Development Tasks:**
- Write, edit, and review code
- Run builds and tests
- Deploy applications
- Fix bugs and implement features

**üìû Communication:**
- Respond instantly to SMS and email
- Send progress reports and updates
- Answer technical questions
- Provide code explanations

**üîß Quick Commands:**
- Send "status" for project overview
- Ask specific questions about your code
- Request new features or bug fixes
- Get help with debugging

Just send me your requests naturally - I'll understand and execute them immediately!

Best regards,
Your Boss Assistant ü§ñ`;
  }
}